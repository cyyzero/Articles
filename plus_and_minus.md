---
title: c++的ub还真是无处不在啊
date: 2017-11-13 23:59:56
tags:
- c++
---

最近发现了一个有意思的东西，所以特意分享下。

问题的引入是如何交换两个整型变量?最简单的就是引入第三个变量,然后完成三次赋值达到交换的目的。
然后，也有一些不使用第三个变量达到这个目的的方法。我所知道的有两个，一个是通过位运算的异或（原理是对于任意位模式ｘ^x = 0,在此不展开），还有一个就是通过以下的方法：
```cpp
void swap(Type& x, Type& y)
{
	x = x+y;
	y = x-y;
	x = x-y;
}
```
（可以看到我这里没有说明具体变量类型，原因往下看就知道了=。=）

肯定有人一眼就看出了这个方法的问题：x+y有可能会溢出。

一般程序猿看到溢出就头疼，感觉肯定潜藏着bug，然而事实真是如此吗？

本篇文章的想要探讨的问题：**这种方法最终结果还能保证交换结果正确吗？**

大家都知道，在计算机的世界中，一切的整型最后都是用二进制来表示。对于有符号整型和无符号整型来说，有着不同的编码规则。

BTW，现在都是用补码来表示有符号数，而不是国内教材讲半天的原码和反码：）

所以，对于一个n位的二进制，当它表示一个无符号整型的时候，第i(i取1~n)位的权重就是2^(i-1)。当它表示一个有符号整型的时候，第n位的权重是-2^(n-1)，第i(i取1~k-1)位的权重是2^(i-1)。

至于用补码来表示有符号数的原因，就是可以在cpu内部运算时不用区分有符号和无符号整型，用同一套加法器就能解决。这里可以自己推理或者实验一下，但弄不明白为什么也没关系，只要记住结论：**有符号整型和无符号整型在cpu上的运算规律相同，即将减去一个减数换成加上它的补码，然后二进制数逐位相加，最高位进位舍弃**（这个很好理解，因为运算时的bit数（高层上就是数据类型）固定）。

所以，这些运算最后都能看成是一个无符号整型的加法。这是一个取模加法。也就是说发生了截断，最高位进位被舍弃。相当于每次结果对2^k取模。

这在数学上有定义，模数加法形成了一个阿贝尔群。阿贝尔群的性质就是**可交换**和**可结合**。不懂什么是阿贝尔群没关系，看到可交换和可结合，相信大家心里已经有点数了：用上面那个方法交换变量应该是可行的。
我把交换的过程运算详细列出来。
| x | y |
|---|---|
|x+y| y |
|x+y| x+y-y |
| x+y-x-y+y | x+y-y | 

可以看到根据取模加法**可交换可结合**的特点x最后的结果是x+y-x-y+y=y，y最后的结果x+y-y=x。

到这里似乎完事大吉,但是心头隐隐有些不安。而且某次在某个群里讨论这个话题的时候也被dalao喷过：-（  所以感觉这个还和语言的标准有关。后来查了下c++对于有符号数无符号数，以及溢出的资料，果然如此...

对于无符号整型来说：
>Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2^n where n is the number of bits in the value representation of that particular size of integer


标准是明确规定无符号整型运算结果会以2^n取模，即使溢出了运算结果也是明确数学定义的（mathematically defined）。也就构成了模数加法，可交换可结合。

而对于有符号整型：

C++11, §18.4.1:

>The header defines all functions, types, and macros the same as 7.20 in the C standard.

好吧，一切按照c的来：

C11, §7.20.1.1:
>The typedef name intN_t designates a signed integer type with width N, no padding bits, and a two’s complement representation. Thus, int8\_t denotes such a signed integer type with a width of exactly 8 bits.

c++11明确规定了有符号类型用了补码表示。但是并没有像无符号类型那样，定义了溢出之后对结果取模。也就是说，有符号类型溢出是未定义的。所以用上面那个方法交换的结果也是未定义。

最后的结论：在c++中，无符号整型用上述方法可以交换变量，而有符号整型交换后结果未定义。

ps：不过估计对于大多数编译器实现来说有符号整型交换这么来也是可以的...毕竟cpu运算结果就是那样 orz